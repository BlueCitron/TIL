# CHAPTER7 COMMAND_PATTERN(커맨드 패턴)

> 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자 클래스와 실제 기능을 실행하는 수신자 클래스 사이의 의존성을 제거한다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해준다.

커맨드 패턴은 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다.


### 문제점
* A. 누군가 다른 버튼을 눌렀을 때 램프가 켜지는 대신 다른 기능을 실행하게 하려면 어떤 변경 작업을 해야하는가?
    * 예를 들어 버튼을 눌렀을 때 알람이 시작되기 하려면?
* B. 버튼을 누르는 동작에 따라 다른 기능을 실행하게 하려면 어떤 변경 작업을 해야 하는가?
    * 예를 들어 버튼을 처음 눌렀을 때는 램프를 켜고, 두 번째 눌렀을 때는 알람을 동작하게 하려면?

### 문제점 A
Button 클래스의 필드와 pressed 메서드를 수정함으로써 다른 기능(알람)이 실행되도록 변경할 수 있었다. 하지만 기능을 변경하기 위해 기존의 Button 클래스를 수정하는 것은 OCP 원칙에 위배된다.
즉, 버튼을 눌렀을 때 지정된 특정 기능(처음에는 램프 켜기)만 고정적으로 수행하도록 만든 처음 디자인은 다른 기능(알람)을 추가할 때 pressed 메서드 전체를 변경해야 하므로 OCP 원칙을 위배하는 것이다.

### 문제점 B
이 경우 역시 버튼을 눌렀을 때의 기능을 변경하기 위해 다시 Button 클래스의 코드를 수정했다. 
이러한 수정은 버튼을 눌렀을 때 필요한 기능을 새로 추가할 때 마다 반복적으로 발생할 것이다.
즉, Button 클래스에 새로 기능을 추가할 때 마다 코드를 수정해야 한다면 Button 클래스를 재사용하기 어렵다.

### 해결책
* Button 클래스의 pressed 메서드에서 구체적인 기능(램프 켜기, 알람 동작 등)을 직접 구현 X(변경 포인트를 캡슐화)
* Button을 눌렀을 때의 동작을 외부에서 제공받아 캡슐화해 pressed 메서드에서 호출

